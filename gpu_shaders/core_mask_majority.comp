#version 450

// Majority fusion for signed-ternary carriers.
// Inputs are channel-major: K channels of length N each, flattened as
//   idx = j * N + i
// where j in [0, K) is the channel and i in [0, N) is the element.
//
// support_in: uint (0/1)
// sign_in:    int  (-1/+1) meaningful only when support_in == 1
// Outputs:
//   support_out: 1 if a strict majority exists, else 0
//   sign_out:    majority sign when support_out==1, arbitrary when 0
//
// Tie rule: if votes cancel (v == 0), project â†’ support_out=0 (no winner).

layout(local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly buffer SupportIn {
    uint data[];
} support_in;

layout(std430, set = 0, binding = 1) readonly buffer SignIn {
    int data[];
} sign_in;

layout(std430, set = 0, binding = 2) writeonly buffer SupportOut {
    uint data[];
} support_out;

layout(std430, set = 0, binding = 3) writeonly buffer SignOut {
    int data[];
} sign_out;

layout(push_constant) uniform PushConsts {
    uint n;  // elements per channel
    uint k;  // number of channels
} pc;

void main() {
    uint i = gl_GlobalInvocationID.x;
    if (i >= pc.n) {
        return;
    }

    int vote = 0;
    uint count = 0;

    // channel-major layout
    for (uint j = 0; j < pc.k; ++j) {
        uint idx = j * pc.n + i;
        uint m = support_in.data[idx];
        if (m != 0u) {
            count += 1u;
            int s = sign_in.data[idx];
            vote += (s > 0) ? 1 : -1;  // only sign matters
        }
    }

    if (count == 0u) {
        support_out.data[i] = 0u;
        sign_out.data[i] = 1;  // arbitrary when support is zero
    } else if (vote > 0) {
        support_out.data[i] = 1u;
        sign_out.data[i] = 1;
    } else if (vote < 0) {
        support_out.data[i] = 1u;
        sign_out.data[i] = -1;
    } else {
        // tie: project away
        support_out.data[i] = 0u;
        sign_out.data[i] = 1;
    }
}

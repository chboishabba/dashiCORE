#version 450
layout(local_size_x = 16, local_size_y = 16) in;

/*
WARP_PIECEWISE:
Like warp_affine_2d, but intended as the canonical "piecewise chart" warp.
Per-tile 2x3 affine parameters.
*/

layout(std430, set=0, binding=0) readonly buffer SRC { float src[]; };
layout(std430, set=0, binding=1) writeonly buffer DST { float dst[]; };
layout(std430, set=0, binding=2) readonly buffer AFF { float tile_affine[]; }; // 6 floats per tile

layout(push_constant) uniform PC {
  uint w;
  uint h;
  uint tile_w;
  uint tile_h;
  uint tiles_x;
} pc;

int clampi(int v, int lo, int hi) { return v < lo ? lo : (v > hi ? hi : v); }

void main() {
  uint x = gl_GlobalInvocationID.x;
  uint y = gl_GlobalInvocationID.y;
  if (x >= pc.w || y >= pc.h) return;

  uint tx = x / pc.tile_w;
  uint ty = y / pc.tile_h;
  uint tile = ty * pc.tiles_x + tx;
  uint base = tile * 6u;

  float a = tile_affine[base + 0u];
  float b = tile_affine[base + 1u];
  float c = tile_affine[base + 2u];
  float d = tile_affine[base + 3u];
  float e = tile_affine[base + 4u];
  float f = tile_affine[base + 5u];

  float xs = a * float(x) + b * float(y) + c;
  float ys = d * float(x) + e * float(y) + f;

  int xi = clampi(int(round(xs)), 0, int(pc.w) - 1);
  int yi = clampi(int(round(ys)), 0, int(pc.h) - 1);

  dst[y * pc.w + x] = src[uint(yi) * pc.w + uint(xi)];
}

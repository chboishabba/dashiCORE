#version 450

// Signed-filament coherence annihilation + per-workgroup metrics.

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly buffer SignIn {
    int data[];
} sign_in;

layout(std430, set = 0, binding = 1) buffer SignOut {
    int data[];
} sign_out;

layout(std430, set = 0, binding = 2) readonly buffer OmegaBuf {
    float data[];
} omega_buf;

layout(std430, set = 0, binding = 3) buffer Metrics {
    vec4 data[];
} metrics_out;

layout(push_constant) uniform PushConsts {
    uint N;
    float coherence_min;
    uint write_metrics;
} pc;

shared float sh_count_before[256];
shared float sh_count_after[256];
shared float sh_sum_before[256];
shared float sh_sum_after[256];

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint N = pc.N;
    uint lid = gl_LocalInvocationID.y * gl_WorkGroupSize.x + gl_LocalInvocationID.x;

    float count_before = 0.0;
    float count_after = 0.0;
    float sum_before = 0.0;
    float sum_after = 0.0;

    int out_val = 0;
    if (x < N && y < N) {
        uint idx = y * N + x;
        int s0 = sign_in.data[idx];
        float omega = omega_buf.data[idx];
        if (s0 != 0) {
            count_before = 1.0;
            sum_before = abs(omega);
        }

        int sum_sign = 0;
        int count_nonzero = 0;
        for (int dy = -1; dy <= 1; ++dy) {
            int ny = int(y) + dy;
            if (ny < 0 || ny >= int(N)) {
                continue;
            }
            for (int dx = -1; dx <= 1; ++dx) {
                int nx = int(x) + dx;
                if (nx < 0 || nx >= int(N)) {
                    continue;
                }
                uint nidx = uint(ny) * N + uint(nx);
                int s = sign_in.data[nidx];
                if (s != 0) {
                    sum_sign += s;
                    count_nonzero += 1;
                }
            }
        }

        float coherence = 0.0;
        if (count_nonzero > 0) {
            coherence = abs(float(sum_sign)) / float(count_nonzero);
        }

        if (coherence >= pc.coherence_min && sum_sign != 0) {
            out_val = (sum_sign > 0) ? 1 : -1;
        } else {
            out_val = 0;
        }
        sign_out.data[idx] = out_val;

        if (out_val != 0) {
            count_after = 1.0;
            sum_after = abs(omega);
        }
    }

    sh_count_before[lid] = count_before;
    sh_count_after[lid] = count_after;
    sh_sum_before[lid] = sum_before;
    sh_sum_after[lid] = sum_after;
    barrier();

    for (uint stride = 128; stride > 0; stride >>= 1) {
        if (lid < stride) {
            sh_count_before[lid] += sh_count_before[lid + stride];
            sh_count_after[lid] += sh_count_after[lid + stride];
            sh_sum_before[lid] += sh_sum_before[lid + stride];
            sh_sum_after[lid] += sh_sum_after[lid + stride];
        }
        barrier();
    }

    if (lid == 0 && pc.write_metrics != 0u) {
        uint gx = gl_WorkGroupID.x;
        uint gy = gl_WorkGroupID.y;
        uint group_id = gy * gl_NumWorkGroups.x + gx;
        metrics_out.data[group_id] = vec4(
            sh_count_before[0],
            sh_count_after[0],
            sh_sum_before[0],
            sh_sum_after[0]
        );
    }
}

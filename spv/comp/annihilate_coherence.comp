#version 450

// Signed-filament coherence annihilation with lifetime update + compact metrics.

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(std430, set = 0, binding = 0) readonly buffer SignIn {
    int data[];
} sign_in;

layout(std430, set = 0, binding = 1) buffer SignOut {
    int data[];
} sign_out;

layout(std430, set = 0, binding = 2) buffer LifetimeBuf {
    uint data[];
} lifetime;

layout(std430, set = 0, binding = 3) buffer Metrics {
    uint alive_count;
    uint killed_count;
    uint max_lifetime;
    uint _pad0;
} metrics_out;

layout(push_constant) uniform PushConsts {
    uint N;
    float coherence_min;
    uint min_life;
    uint write_metrics;
} pc;

uint wrap_u(int v, uint N) {
    int m = v % int(N);
    if (m < 0) {
        m += int(N);
    }
    return uint(m);
}

void main() {
    uint x = gl_GlobalInvocationID.x;
    uint y = gl_GlobalInvocationID.y;
    uint N = pc.N;
    if (x >= N || y >= N) {
        return;
    }

    uint idx = y * N + x;
    int s0 = sign_in.data[idx];
    bool supported = (s0 != 0);

    int sum_sign = 0;
    int count_nonzero = 0;
    if (supported) {
        for (int dy = -1; dy <= 1; ++dy) {
            for (int dx = -1; dx <= 1; ++dx) {
                uint nx = wrap_u(int(x) + dx, N);
                uint ny = wrap_u(int(y) + dy, N);
                uint nidx = ny * N + nx;
                int s = sign_in.data[nidx];
                if (s != 0) {
                    sum_sign += s;
                    count_nonzero += 1;
                }
            }
        }
    }

    float coherence = 0.0;
    if (count_nonzero > 0) {
        coherence = abs(float(sum_sign)) / float(count_nonzero);
    }

    bool survive = supported && (coherence >= pc.coherence_min) && (sum_sign != 0);
    int out_val = 0;
    if (survive) {
        out_val = (sum_sign > 0) ? 1 : -1;
        uint lt = lifetime.data[idx];
        if (lt != 0xFFFFFFFFu) {
            lt += 1u;
        }
        lifetime.data[idx] = lt;
        if (pc.write_metrics != 0u) {
            if (lt >= pc.min_life) {
                atomicAdd(metrics_out.alive_count, 1u);
            }
            atomicMax(metrics_out.max_lifetime, lt);
        }
    } else {
        if (supported && pc.write_metrics != 0u) {
            atomicAdd(metrics_out.killed_count, 1u);
        }
        lifetime.data[idx] = 0u;
        out_val = 0;
    }

    sign_out.data[idx] = out_val;
}
